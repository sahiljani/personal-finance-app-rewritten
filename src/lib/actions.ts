
"use server";

import { type Expense, type Category, type ExtractedReceiptItem } from "@/lib/types";
import { z } from "zod";
import { revalidatePath } from "next/cache";
import { createClient } from "@/lib/supabase/client"; // Import Supabase server client factory function
import { extractReceiptData } from "@/ai/flows/extract-receipt-data";
import { suggestCategoryFlow } from "@/ai/flows/suggest-category-flow";

// --- Data Schemas (using Supabase conventions) ---

// Category Schema matches the DB table
const CategorySchema = z.object({
  id: z.string().uuid().optional(), // UUID generated by DB or client
  name: z.string().min(1, "Category name cannot be empty"),
  icon: z.string().optional().nullable(), // Allow null in DB
  created_at: z.string().datetime().optional(), // Timestamps handled by DB
});

// Expense Schema matches the DB table
const ExpenseSchema = z.object({
  id: z.string().uuid().optional(), // UUID generated by DB
  amount: z.number().positive("Amount must be positive"),
  description: z.string().min(1, "Description cannot be empty"),
  category_id: z.string().min(1, "Category is required"), // Use category_id (matches DB foreign key)
  date: z.string().datetime("Invalid date format"), // ISO 8601 string
  receipt_url: z.string().optional().nullable(), // Allow null in DB
  created_at: z.string().datetime().optional(), // Timestamps handled by DB
});

// Type mapping to frontend types (adjust if needed)
function mapExpenseFromDb(dbExpense: any): Expense {
  // Basic validation to ensure dbExpense is an object and has necessary fields
  if (typeof dbExpense !== 'object' || dbExpense === null || !dbExpense.id || !dbExpense.date) {
     console.error("Invalid data received in mapExpenseFromDb:", dbExpense);
     throw new Error("Invalid database expense data received.");
  }
  return {
    id: dbExpense.id,
    amount: Number(dbExpense.amount) || 0, // Ensure amount is number
    description: dbExpense.description ?? '', // Ensure description is string
    categoryId: dbExpense.category_id ?? '', // Ensure categoryId is string
    date: dbExpense.date, // Assume date is correct format from DB
    receiptUrl: dbExpense.receipt_url,
  };
}

function mapCategoryFromDb(dbCategory: any): Category {
   // Basic validation
   if (typeof dbCategory !== 'object' || dbCategory === null || !dbCategory.id || !dbCategory.name) {
      console.error("Invalid data received in mapCategoryFromDb:", dbCategory);
      throw new Error("Invalid database category data received.");
   }
  return {
    id: dbCategory.id,
    name: dbCategory.name,
    icon: dbCategory.icon,
  };
}


// --- Expense Actions ---

export async function getExpenses(
  filters?: { dateFrom?: string; dateTo?: string; categoryId?: string }
): Promise<Expense[]> {
  const supabase = createClient(); // Create client inside the action
  let query = supabase.from("expenses").select("*");

  // Apply filters
  if (filters?.dateFrom) {
    query = query.gte('date', filters.dateFrom);
  }
  if (filters?.dateTo) {
    // Adjust end date to be inclusive (end of the day) or exclusive (start of next day)
    // Supabase date filtering is usually inclusive on both ends by default
    // For consistency with previous logic, let's query up to the *start* of the next day
    const endDate = new Date(filters.dateTo);
    endDate.setDate(endDate.getDate() + 1);
    query = query.lt('date', endDate.toISOString().split('T')[0]); // Use 'YYYY-MM-DD' format
  }
  if (filters?.categoryId) {
    query = query.eq('category_id', filters.categoryId); // Use DB column name
  }

  // Order by date descending
  query = query.order('date', { ascending: false });

  const { data, error } = await query;

  if (error) {
    // Log the detailed error object from Supabase
    console.error("Error fetching expenses (Raw Object):", error);
    console.error(`Error fetching expenses (Message): ${error.message}, (Code): ${error.code}, (Details): ${error.details}, (Hint): ${error.hint}`);

    // Provide more specific error context if possible
    let userMessage = "Could not fetch expenses.";
    if (error.code === '42P01') { // PostgreSQL error code for 'undefined_table'
      userMessage = "Database error: The 'expenses' table could not be found. Please check the database schema setup instructions in README.md and ensure migrations have been applied.";
    } else if (error.message.includes('permission denied')) { // Check for RLS issues
      userMessage = "Permission denied fetching expenses. Please check Row Level Security (RLS) policies on the 'expenses' table in Supabase to allow read access.";
    } else if (error.message.includes('NetworkError')) {
        userMessage = "Network error: Could not connect to the database.";
    } else if (error.message.includes('Invalid API key')) {
        userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
    } else {
        // Fallback using Supabase error details if available
        userMessage += ` ${error.message || '(Check Supabase connection/permissions)'}${error.details ? ` (${error.details})` : ''}`;
    }
    console.error("Throwing user-facing error:", userMessage); // Log the final error message being thrown
    throw new Error(userMessage);
  }

  try {
      // Add explicit validation/mapping step
      return data?.map(mapExpenseFromDb) ?? [];
  } catch (mappingError) {
      console.error("Error mapping database expenses to frontend type:", mappingError);
      throw new Error("Failed to process expense data from database.");
  }
}

export async function addExpense(expenseData: Omit<Expense, "id" | "receiptUrl"> & { receiptUrl?: string | null }): Promise<Expense> {
   const supabase = createClient(); // Create client inside the action
   // Validate incoming data against the frontend structure first
   const validatedFrontendData = ExpenseSchema.omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
       categoryId: z.string().min(1, "Category is required"),
       receiptUrl: z.string().optional().nullable(),
       date: z.string().datetime("Invalid date format"), // Ensure date is validated here
   }).parse(expenseData);

   // Prepare data for Supabase insertion (map frontend fields to DB fields)
    const dataToInsert = {
        amount: validatedFrontendData.amount,
        description: validatedFrontendData.description,
        category_id: validatedFrontendData.categoryId, // Map to category_id
        date: validatedFrontendData.date,
        receipt_url: validatedFrontendData.receiptUrl,
    };

    // Insert into Supabase
    const { data, error } = await supabase
        .from("expenses")
        .insert(dataToInsert)
        .select() // Return the inserted row
        .single(); // Expect only one row back

    if (error) {
        console.error("Error adding expense:", error);
        let userMessage = "Could not add expense.";
        if (error.code === '23503') { // Foreign key violation
             userMessage = "Could not add expense: Invalid category selected.";
        } else if (error.code === '42P01') {
            userMessage = "Database error: The 'expenses' table could not be found. Check schema/migrations.";
        } else if (error.message.includes('permission denied')) {
             userMessage = "Permission denied adding expense. Check RLS policies on 'expenses'.";
        } else if (error.message.includes('Invalid API key')) {
           userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
        } else {
            userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }

    revalidatePath("/");
    revalidatePath("/reports");

     try {
        // Map DB result back to frontend type
        return mapExpenseFromDb(data);
    } catch (mappingError) {
        console.error("Error mapping added expense from DB:", mappingError);
        throw new Error("Expense added, but failed to process the returned data.");
    }
}

export async function addExpensesBatch(expenseDataArray: Omit<Expense, "id" | "receiptUrl">[]): Promise<Expense[]> {
    const supabase = createClient(); // Create client inside the action
    const expensesToInsert = expenseDataArray.map(expenseData => {
         // Validate each item individually (optional, but good practice)
         const validatedFrontendData = ExpenseSchema.omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
             categoryId: z.string().min(1, "Category is required"),
             receiptUrl: z.string().optional().nullable(),
             date: z.string().datetime("Invalid date format"), // Ensure date is validated here
         }).parse(expenseData);

         return {
             amount: validatedFrontendData.amount,
             description: validatedFrontendData.description,
             category_id: validatedFrontendData.categoryId,
             date: validatedFrontendData.date,
             receipt_url: validatedFrontendData.receiptUrl,
         };
    });

    const { data, error } = await supabase
        .from("expenses")
        .insert(expensesToInsert)
        .select();

    if (error) {
        console.error("Error adding expenses batch:", error);
         let userMessage = "Could not add expenses batch.";
         if (error.code === '42P01') {
             userMessage = "Database error: The 'expenses' table could not be found. Check schema/migrations.";
         } else if (error.message.includes('permission denied')) {
              userMessage = "Permission denied adding expenses batch. Check RLS policies on 'expenses'.";
         } else if (error.message.includes('Invalid API key')) {
            userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
         } else {
             userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
         }
        throw new Error(userMessage);
    }

    revalidatePath("/");
    revalidatePath("/reports");

     try {
        return data?.map(mapExpenseFromDb) ?? [];
    } catch (mappingError) {
        console.error("Error mapping batch added expenses from DB:", mappingError);
        throw new Error("Expenses added, but failed to process the returned data.");
    }
}


export async function updateExpense(id: string, updates: Partial<Omit<Expense, "id" | "receiptUrl">> & { receiptUrl?: string | null }): Promise<Expense> {
    const supabase = createClient(); // Create client inside the action
    // Validate the partial update data
    const partialFrontendSchema = ExpenseSchema.partial().omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
        categoryId: z.string().optional(),
        receiptUrl: z.string().optional().nullable(),
        date: z.string().datetime("Invalid date format").optional(), // Allow optional date update
    });
    const validatedUpdates = partialFrontendSchema.parse(updates);

    // Map frontend fields to DB fields for the update payload
    const dataToUpdate: { [key: string]: any } = {};
    if (validatedUpdates.amount !== undefined) dataToUpdate.amount = validatedUpdates.amount;
    if (validatedUpdates.description !== undefined) dataToUpdate.description = validatedUpdates.description;
    if (validatedUpdates.categoryId !== undefined) dataToUpdate.category_id = validatedUpdates.categoryId;
    if (validatedUpdates.date !== undefined) dataToUpdate.date = validatedUpdates.date;
    if (validatedUpdates.receiptUrl !== undefined) dataToUpdate.receipt_url = validatedUpdates.receiptUrl;

     // Check if there's anything to update
    if (Object.keys(dataToUpdate).length === 0) {
       // Fetch the current expense if no updates are provided, maybe return it?
       // Or throw an error? Let's fetch and return for now.
        const { data: currentData, error: currentError } = await supabase
            .from('expenses')
            .select('*')
            .eq('id', id)
            .single();
        if (currentError || !currentData) {
             console.error("Error fetching expense for empty update:", currentError);
             throw new Error("Expense not found or could not be fetched.");
        }
         return mapExpenseFromDb(currentData);
     }


    const { data, error } = await supabase
        .from("expenses")
        .update(dataToUpdate)
        .eq("id", id)
        .select()
        .single();

    if (error) {
        console.error("Error updating expense:", error);
        let userMessage = "Could not update expense.";
        if (error.code === 'PGRST116') { // Resource Not Found (PostgREST code)
            userMessage = "Expense not found for update.";
        } else if (error.code === '23503') { // Foreign key violation
            userMessage = "Could not update expense: Invalid category selected.";
        } else if (error.code === '42P01') {
             userMessage = "Database error: The 'expenses' table could not be found. Check schema/migrations.";
        } else if (error.message.includes('permission denied')) {
             userMessage = "Permission denied updating expense. Check RLS policies on 'expenses'.";
        } else if (error.message.includes('Invalid API key')) {
             userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
        } else {
            userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }
     if (!data) {
         throw new Error("Expense not found after update attempt.");
     }

    revalidatePath("/");
    revalidatePath("/reports");
    try {
        return mapExpenseFromDb(data);
     } catch (mappingError) {
         console.error("Error mapping updated expense from DB:", mappingError);
         throw new Error("Expense updated, but failed to process the returned data.");
     }
}

export async function deleteExpense(id: string): Promise<void> {
    const supabase = createClient(); // Create client inside the action
    const { error } = await supabase
        .from("expenses")
        .delete()
        .eq("id", id);

    if (error) {
        console.error("Error deleting expense:", error);
        let userMessage = "Could not delete expense.";
         if (error.code === '42P01') {
             userMessage = "Database error: The 'expenses' table could not be found. Check schema/migrations.";
         } else if (error.message.includes('permission denied')) {
              userMessage = "Permission denied deleting expense. Check RLS policies on 'expenses'.";
         } else if (error.message.includes('Invalid API key')) {
             userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
         } else {
            userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
         }
        throw new Error(userMessage);
    }
    // We can't easily check if a row was actually deleted without another query,
    // but Supabase delete doesn't error if the row doesn't exist with `eq`.

    revalidatePath("/");
    revalidatePath("/reports");
}


// --- Category Actions ---

export async function getCategories(): Promise<Category[]> {
    const supabase = createClient(); // Create client inside the action
    const { data, error } = await supabase
        .from("categories")
        .select("*")
        .order('name', { ascending: true }); // Optional: order by name

     if (error) {
        // Log the detailed error object from Supabase
        console.error("Error fetching categories (Raw Object):", error);
        console.error(`Error fetching categories (Message): ${error.message}, (Code): ${error.code}, (Details): ${error.details}, (Hint): ${error.hint}`);
        // Provide more specific error context if possible
        let userMessage = "Could not fetch categories.";
        if (error.code === '42P01') { // PostgreSQL error code for 'undefined_table'
           userMessage = "Database error: The 'categories' table could not be found. Please check the database schema setup instructions in README.md and ensure migrations have been applied.";
        } else if (error.message.includes('permission denied')) { // Check for RLS issues
           userMessage = "Permission denied fetching categories. Please check Row Level Security (RLS) policies on the 'categories' table in Supabase to allow read access.";
        } else if (error.message.includes('NetworkError')) {
           userMessage = "Network error: Could not connect to the database.";
        } else if (error.message.includes('Invalid API key')) {
            userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
        } else {
            // Fallback using Supabase error details if available
            userMessage += ` ${error.message || '(Check Supabase connection/permissions)'}${error.details ? ` (${error.details})` : ''}`;
        }
        console.error("Throwing user-facing error:", userMessage); // Log the final error message being thrown
        throw new Error(userMessage);
    }

     try {
        // Add explicit validation/mapping step
        return data?.map(mapCategoryFromDb) ?? [];
    } catch (mappingError) {
        console.error("Error mapping database categories to frontend type:", mappingError);
        throw new Error("Failed to process category data from database.");
    }
}

// Note: Adding categories might require specific DB setup (e.g., RLS policies)
// The ID is usually handled by Supabase (UUID)
export async function addCategory(categoryData: Omit<Category, "id">): Promise<Category> {
    const supabase = createClient(); // Create client inside the action
    const validatedData = CategorySchema.omit({ id: true, created_at: true }).parse(categoryData);

     // Optional: Check for duplicate names server-side before inserting
     const { data: existing, error: existingError } = await supabase
         .from('categories')
         .select('id')
         .ilike('name', validatedData.name) // Case-insensitive check
         .maybeSingle();

      if (existingError) {
          console.error("Error checking for existing category:", existingError);
          // Decide if this is fatal or just a warning
          // throw new Error("Could not verify existing categories.");
      }
      if (existing) {
          throw new Error(`Category with name "${validatedData.name}" already exists.`);
      }

    const { data, error } = await supabase
        .from("categories")
        .insert({
            name: validatedData.name,
            icon: validatedData.icon,
        })
        .select()
        .single();

    if (error) {
        console.error("Error adding category:", error);
        let userMessage = "Could not add category.";
        if (error.code === '42P01') {
             userMessage = "Database error: The 'categories' table could not be found. Check schema/migrations.";
        } else if (error.message.includes('permission denied')) {
             userMessage = "Permission denied adding category. Check RLS policies on 'categories'.";
        } else if (error.message.includes('Invalid API key')) {
            userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
        } else {
             userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }

    revalidatePath("/");
     try {
         return mapCategoryFromDb(data);
     } catch (mappingError) {
         console.error("Error mapping added category from DB:", mappingError);
         throw new Error("Category added, but failed to process the returned data.");
     }
}

export async function updateCategory(id: string, updates: Partial<Omit<Category, "id">>): Promise<Category> {
    const supabase = createClient(); // Create client inside the action
    const partialSchema = CategorySchema.partial().omit({ id: true, created_at: true });
    const validatedUpdates = partialSchema.parse(updates);

     // Optional: Check for duplicate names if name is changing
     if (validatedUpdates.name) {
         const { data: existing, error: existingError } = await supabase
             .from('categories')
             .select('id')
             .ilike('name', validatedUpdates.name)
             .neq('id', id) // Exclude the current category being updated
             .maybeSingle();

         if (existingError) {
             console.error("Error checking for existing category name:", existingError);
             // Decide if this is fatal or just a warning
         }
         if (existing) {
             throw new Error(`Another category with the name "${validatedUpdates.name}" already exists.`);
         }
     }

    const { data, error } = await supabase
        .from("categories")
        .update({
            name: validatedUpdates.name,
            icon: validatedUpdates.icon,
        })
        .eq("id", id)
        .select()
        .single();

    if (error) {
        console.error("Error updating category:", error);
        let userMessage = "Could not update category.";
         if (error.code === 'PGRST116') {
            userMessage = "Category not found for update.";
        } else if (error.code === '42P01') {
             userMessage = "Database error: The 'categories' table could not be found. Check schema/migrations.";
        } else if (error.message.includes('permission denied')) {
             userMessage = "Permission denied updating category. Check RLS policies on 'categories'.";
        } else if (error.message.includes('Invalid API key')) {
            userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
        } else {
             userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }
     if (!data) {
         throw new Error("Category not found after update attempt.");
     }

    revalidatePath("/");
     try {
         return mapCategoryFromDb(data);
     } catch (mappingError) {
         console.error("Error mapping updated category from DB:", mappingError);
         throw new Error("Category updated, but failed to process the returned data.");
     }
}

export async function deleteCategory(id: string): Promise<void> {
    const supabase = createClient(); // Create client inside the action

    // Check if any expenses use this category
    // Important: Ensure RLS allows checking expenses table if applicable
     const { count, error: expensesError } = await supabase
         .from('expenses')
         .select('id', { count: 'exact', head: true }) // Use head: true for count only
         .eq('category_id', id); // Filter by the category being deleted

     if (expensesError) {
         console.error("Error checking for expenses linked to category:", expensesError);
         // Check specifically for missing 'expenses' table
         if (expensesError.code === '42P01') {
             throw new Error("Database error: Could not check for linked expenses because the 'expenses' table was not found.");
         } else if (expensesError.message.includes('permission denied')) {
             throw new Error("Permission denied checking linked expenses. Check RLS policies on 'expenses'.");
         }
         throw new Error(`Could not verify if category is in use. ${expensesError.message}`);
     }

     const expenseCount = count ?? 0;

    if (expenseCount > 0) {
        throw new Error(`Cannot delete category: It is assigned to ${expenseCount} expense(s). Please reassign them first.`);
    }

    // Proceed with deletion if no expenses are linked
    const { error } = await supabase
        .from("categories")
        .delete()
        .eq("id", id);

    if (error) {
        console.error("Error deleting category:", error);
        let userMessage = "Could not delete category.";
        if (error.code === '42P01') {
            userMessage = "Database error: The 'categories' table could not be found. Check schema/migrations.";
        } else if (error.message.includes('permission denied')) {
             userMessage = "Permission denied deleting category. Check RLS policies on 'categories'.";
        } else if (error.message.includes('Invalid API key')) {
            userMessage = "Authentication error: Invalid Supabase API key. Check your .env file.";
        } else {
            userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }

    revalidatePath("/");
}

// --- AI Receipt Processing Action ---

/**
 * Processes a receipt file (image or PDF) using an AI flow to extract items.
 * Calls the Genkit flow `extractReceiptData`.
 * @param fileDataUri The receipt file encoded as a data URI.
 * @returns A promise that resolves to an array of extracted items, including suggested category IDs.
 */
export async function processReceiptFile(fileDataUri: string): Promise<ExtractedReceiptItem[]> {
    try {
        // Fetch current categories to ensure AI suggestions are validated against available ones
        const categories = await getCategories();
        const validCategoryIds = categories.map(c => c.id);
        // Ensure a valid default exists, even if 'other' is missing
        const defaultCategoryId = categories.find(c => c.id === 'other')?.id || categories[0]?.id;
        if (!defaultCategoryId && categories.length > 0) { // Check if categories array is not empty before throwing
             console.error("No default category found for receipt processing.");
             throw new Error("Configuration error: No default category ('other' or first category) available to assign.");
        } else if (categories.length === 0) {
             throw new Error("No categories found in the database. Please add categories first before processing receipts.");
        }


        // Call the AI flow which returns items with categoryId suggestions
        const result = await extractReceiptData({ fileDataUri });

        // Validate AI's suggested category IDs against the actual categories from the DB
        const validatedResults = result.map(item => ({
            ...item,
            categoryId: validCategoryIds.includes(item.categoryId) ? item.categoryId : defaultCategoryId
        }));

        return validatedResults;
    } catch (error) {
        console.error("Error processing receipt with AI:", error);
        if (error instanceof z.ZodError) {
             console.error("Zod validation error during AI processing:", error.errors);
             throw new Error("Invalid data structure received from AI processing.");
        } else if (error instanceof Error) {
             // Make error message more user-friendly
             if (error.message.includes("No categories found")) {
                 throw new Error("Cannot process receipt: No categories are set up in the application.");
             }
             // Pass through more specific errors from getCategories if relevant
             if (error.message.includes("Database error:") || error.message.includes("Network error:")) {
                  throw error; // Re-throw the specific database/network error
             }
             throw new Error(`Failed to process receipt: ${error.message}`);
        } else {
            throw new Error("An unknown error occurred while processing the receipt.");
        }
    }
}

// --- AI Category Suggestion Action ---
/**
 * Suggests a category ID based on the item description using a Genkit AI flow.
 * @param description The description of the expense item.
 * @returns A suggested category ID string or null if no suggestion is made or an error occurs.
 */
export async function suggestCategory(description: string): Promise<string | null> {
  if (!description || description.trim().length === 0) {
    return null;
  }
  try {
    const categories = await getCategories();
    if (categories.length === 0) {
        console.warn("Cannot suggest category: No categories found in the database.");
        return null; // Or return 'other' if it exists conceptually
    }
    const categoryList = categories.map(c => ({ id: c.id, name: c.name }));
    const defaultCategoryId = categories.find(c => c.id === 'other')?.id || null; // Prefer null if 'other' doesn't exist

    const result = await suggestCategoryFlow({ description, categories: categoryList });

    // Validate the suggestion against existing categories
    if (result.categoryId && categories.some(c => c.id === result.categoryId)) {
        return result.categoryId;
    } else {
        console.warn(`AI suggested category "${result.categoryId}" which is not in the database or is null. Falling back to default.`);
        return defaultCategoryId; // Fallback to 'other' (or null if 'other' doesn't exist)
    }
  } catch (error) {
    console.error("Error suggesting category with AI:", error);
     // Avoid propagating raw DB errors to the frontend suggestion mechanism
     if (error instanceof Error && (error.message.includes("Database error:") || error.message.includes("Network error:"))){
         console.error("Database/Network error prevented category suggestion.");
         return null;
     }
    return null; // Return null on other errors
  }
}

