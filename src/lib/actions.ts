"use server";

import { type Expense, type Category, type ExtractedReceiptItem } from "@/lib/types";
import { z } from "zod";
import { revalidatePath } from "next/cache";
import { createClient } from "@/lib/supabase/client"; // Import Supabase server client factory function
import { extractReceiptData } from "@/ai/flows/extract-receipt-data";
import { suggestCategoryFlow } from "@/ai/flows/suggest-category-flow";

// --- Data Schemas (using Supabase conventions) ---

// Category Schema matches the DB table
const CategorySchema = z.object({
  id: z.string().uuid().optional(), // UUID generated by DB or client
  name: z.string().min(1, "Category name cannot be empty"),
  icon: z.string().optional().nullable(), // Allow null in DB
  created_at: z.string().datetime().optional(), // Timestamps handled by DB
});

// Expense Schema matches the DB table
const ExpenseSchema = z.object({
  id: z.string().uuid().optional(), // UUID generated by DB
  amount: z.number().positive("Amount must be positive"),
  description: z.string().min(1, "Description cannot be empty"),
  category_id: z.string().min(1, "Category is required"), // Use category_id (matches DB foreign key)
  date: z.string().datetime("Invalid date format"), // ISO 8601 string
  receipt_url: z.string().optional().nullable(), // Allow null in DB
  created_at: z.string().datetime().optional(), // Timestamps handled by DB
});

// Type mapping to frontend types (adjust if needed)
function mapExpenseFromDb(dbExpense: any): Expense {
  return {
    id: dbExpense.id,
    amount: dbExpense.amount,
    description: dbExpense.description,
    categoryId: dbExpense.category_id, // Map DB column to frontend property
    date: dbExpense.date,
    receiptUrl: dbExpense.receipt_url,
  };
}

function mapCategoryFromDb(dbCategory: any): Category {
  return {
    id: dbCategory.id,
    name: dbCategory.name,
    icon: dbCategory.icon,
  };
}


// --- Expense Actions ---

export async function getExpenses(
  filters?: { dateFrom?: string; dateTo?: string; categoryId?: string }
): Promise<Expense[]> {
  const supabase = createClient(); // Create client inside the action
  let query = supabase.from("expenses").select("*");

  // Apply filters
  if (filters?.dateFrom) {
    query = query.gte('date', filters.dateFrom);
  }
  if (filters?.dateTo) {
    // Adjust end date to be inclusive (end of the day) or exclusive (start of next day)
    // Supabase date filtering is usually inclusive on both ends by default
    // For consistency with previous logic, let's query up to the *start* of the next day
    const endDate = new Date(filters.dateTo);
    endDate.setDate(endDate.getDate() + 1);
    query = query.lt('date', endDate.toISOString().split('T')[0]); // Use 'YYYY-MM-DD' format
  }
  if (filters?.categoryId) {
    query = query.eq('category_id', filters.categoryId); // Use DB column name
  }

  // Order by date descending
  query = query.order('date', { ascending: false });

  const { data, error } = await query;

  if (error) {
    console.error("Error fetching expenses:", error);
    // Provide more specific error context if possible
    throw new Error(`Could not fetch expenses. ${error.message || '(Check Supabase RLS/Permissions)'}`);
  }

  return data?.map(mapExpenseFromDb) ?? [];
}

export async function addExpense(expenseData: Omit<Expense, "id" | "receiptUrl"> & { receiptUrl?: string | null }): Promise<Expense> {
   const supabase = createClient(); // Create client inside the action
   // Validate incoming data against the frontend structure first
   const validatedFrontendData = ExpenseSchema.omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
       categoryId: z.string().min(1, "Category is required"),
       receiptUrl: z.string().optional().nullable(),
       date: z.string().datetime("Invalid date format"), // Ensure date is validated here
   }).parse(expenseData);

   // Prepare data for Supabase insertion (map frontend fields to DB fields)
    const dataToInsert = {
        amount: validatedFrontendData.amount,
        description: validatedFrontendData.description,
        category_id: validatedFrontendData.categoryId, // Map to category_id
        date: validatedFrontendData.date,
        receipt_url: validatedFrontendData.receiptUrl,
    };

    // Insert into Supabase
    const { data, error } = await supabase
        .from("expenses")
        .insert(dataToInsert)
        .select() // Return the inserted row
        .single(); // Expect only one row back

    if (error) {
        console.error("Error adding expense:", error);
        throw new Error(`Could not add expense. ${error.message || '(Check Supabase RLS/Permissions)'}`);
    }

    revalidatePath("/");
    revalidatePath("/reports");

    // Map DB result back to frontend type
    return mapExpenseFromDb(data);
}

export async function addExpensesBatch(expenseDataArray: Omit<Expense, "id" | "receiptUrl">[]): Promise<Expense[]> {
    const supabase = createClient(); // Create client inside the action
    const expensesToInsert = expenseDataArray.map(expenseData => {
         // Validate each item individually (optional, but good practice)
         const validatedFrontendData = ExpenseSchema.omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
             categoryId: z.string().min(1, "Category is required"),
             receiptUrl: z.string().optional().nullable(),
             date: z.string().datetime("Invalid date format"), // Ensure date is validated here
         }).parse(expenseData);

         return {
             amount: validatedFrontendData.amount,
             description: validatedFrontendData.description,
             category_id: validatedFrontendData.categoryId,
             date: validatedFrontendData.date,
             receipt_url: validatedFrontendData.receiptUrl,
         };
    });

    const { data, error } = await supabase
        .from("expenses")
        .insert(expensesToInsert)
        .select();

    if (error) {
        console.error("Error adding expenses batch:", error);
        throw new Error(`Could not add expenses batch. ${error.message || '(Check Supabase RLS/Permissions)'}`);
    }

    revalidatePath("/");
    revalidatePath("/reports");

    return data?.map(mapExpenseFromDb) ?? [];
}


export async function updateExpense(id: string, updates: Partial<Omit<Expense, "id" | "receiptUrl">> & { receiptUrl?: string | null }): Promise<Expense> {
    const supabase = createClient(); // Create client inside the action
    // Validate the partial update data
    const partialFrontendSchema = ExpenseSchema.partial().omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
        categoryId: z.string().optional(),
        receiptUrl: z.string().optional().nullable(),
        date: z.string().datetime("Invalid date format").optional(), // Allow optional date update
    });
    const validatedUpdates = partialFrontendSchema.parse(updates);

    // Map frontend fields to DB fields for the update payload
    const dataToUpdate: { [key: string]: any } = {};
    if (validatedUpdates.amount !== undefined) dataToUpdate.amount = validatedUpdates.amount;
    if (validatedUpdates.description !== undefined) dataToUpdate.description = validatedUpdates.description;
    if (validatedUpdates.categoryId !== undefined) dataToUpdate.category_id = validatedUpdates.categoryId;
    if (validatedUpdates.date !== undefined) dataToUpdate.date = validatedUpdates.date;
    if (validatedUpdates.receiptUrl !== undefined) dataToUpdate.receipt_url = validatedUpdates.receiptUrl;

     // Check if there's anything to update
    if (Object.keys(dataToUpdate).length === 0) {
       // Fetch the current expense if no updates are provided, maybe return it?
       // Or throw an error? Let's fetch and return for now.
        const { data: currentData, error: currentError } = await supabase
            .from('expenses')
            .select('*')
            .eq('id', id)
            .single();
        if (currentError || !currentData) {
             console.error("Error fetching expense for empty update:", currentError);
             throw new Error("Expense not found or could not be fetched.");
        }
         return mapExpenseFromDb(currentData);
     }


    const { data, error } = await supabase
        .from("expenses")
        .update(dataToUpdate)
        .eq("id", id)
        .select()
        .single();

    if (error) {
        console.error("Error updating expense:", error);
        if (error.code === 'PGRST116') { // Resource Not Found
            throw new Error("Expense not found for update.");
        }
        throw new Error(`Could not update expense. ${error.message || '(Check Supabase RLS/Permissions)'}`);
    }
     if (!data) {
         throw new Error("Expense not found after update attempt.");
     }

    revalidatePath("/");
    revalidatePath("/reports");
    return mapExpenseFromDb(data);
}

export async function deleteExpense(id: string): Promise<void> {
    const supabase = createClient(); // Create client inside the action
    const { error } = await supabase
        .from("expenses")
        .delete()
        .eq("id", id);

    if (error) {
        console.error("Error deleting expense:", error);
        throw new Error(`Could not delete expense. ${error.message || '(Check Supabase RLS/Permissions)'}`);
    }
    // We can't easily check if a row was actually deleted without another query,
    // but Supabase delete doesn't error if the row doesn't exist with `eq`.

    revalidatePath("/");
    revalidatePath("/reports");
}


// --- Category Actions ---

export async function getCategories(): Promise<Category[]> {
    const supabase = createClient(); // Create client inside the action
    const { data, error } = await supabase
        .from("categories")
        .select("*")
        .order('name', { ascending: true }); // Optional: order by name

    if (error) {
        // Log the detailed error object from Supabase
        console.error("Error fetching categories:", error);
        // Throw a more informative error message including details from the Supabase error
        throw new Error(`Could not fetch categories. ${error.message || '(Check RLS policies)'} ${error.details ? `(${error.details})` : ''}`);
    }

    return data?.map(mapCategoryFromDb) ?? [];
}

// Note: Adding categories might require specific DB setup (e.g., RLS policies)
// The ID is usually handled by Supabase (UUID)
export async function addCategory(categoryData: Omit<Category, "id">): Promise<Category> {
    const supabase = createClient(); // Create client inside the action
    const validatedData = CategorySchema.omit({ id: true, created_at: true }).parse(categoryData);

     // Optional: Check for duplicate names server-side before inserting
     const { data: existing, error: existingError } = await supabase
         .from('categories')
         .select('id')
         .ilike('name', validatedData.name) // Case-insensitive check
         .maybeSingle();

      if (existingError) {
          console.error("Error checking for existing category:", existingError);
          // Decide if this is fatal or just a warning
          // throw new Error("Could not verify existing categories.");
      }
      if (existing) {
          throw new Error(`Category with name "${validatedData.name}" already exists.`);
      }

    const { data, error } = await supabase
        .from("categories")
        .insert({
            name: validatedData.name,
            icon: validatedData.icon,
        })
        .select()
        .single();

    if (error) {
        console.error("Error adding category:", error);
        throw new Error(`Could not add category. ${error.message || '(Check Supabase RLS/Permissions)'}`);
    }

    revalidatePath("/");
    return mapCategoryFromDb(data);
}

export async function updateCategory(id: string, updates: Partial<Omit<Category, "id">>): Promise<Category> {
    const supabase = createClient(); // Create client inside the action
    const partialSchema = CategorySchema.partial().omit({ id: true, created_at: true });
    const validatedUpdates = partialSchema.parse(updates);

     // Optional: Check for duplicate names if name is changing
     if (validatedUpdates.name) {
         const { data: existing, error: existingError } = await supabase
             .from('categories')
             .select('id')
             .ilike('name', validatedUpdates.name)
             .neq('id', id) // Exclude the current category being updated
             .maybeSingle();

         if (existingError) {
             console.error("Error checking for existing category name:", existingError);
             // Decide if this is fatal or just a warning
         }
         if (existing) {
             throw new Error(`Another category with the name "${validatedUpdates.name}" already exists.`);
         }
     }

    const { data, error } = await supabase
        .from("categories")
        .update({
            name: validatedUpdates.name,
            icon: validatedUpdates.icon,
        })
        .eq("id", id)
        .select()
        .single();

    if (error) {
        console.error("Error updating category:", error);
         if (error.code === 'PGRST116') {
            throw new Error("Category not found for update.");
        }
        throw new Error(`Could not update category. ${error.message || '(Check Supabase RLS/Permissions)'}`);
    }
     if (!data) {
         throw new Error("Category not found after update attempt.");
     }

    revalidatePath("/");
    return mapCategoryFromDb(data);
}

export async function deleteCategory(id: string): Promise<void> {
    const supabase = createClient(); // Create client inside the action

    // Check if any expenses use this category
     const { data: expenses, error: expensesError } = await supabase
         .from('expenses')
         .select('id', { count: 'exact', head: true }) // Only need the count
         .eq('category_id', id);

     if (expensesError) {
         console.error("Error checking for expenses linked to category:", expensesError);
         throw new Error(`Could not verify if category is in use. ${expensesError.message}`);
     }

     // Use ?.count syntax if available and supported by your Supabase version/types
     // Otherwise, adjust based on how count is returned. Check Supabase docs if needed.
     const expenseCount = (expenses as unknown as { count: number } | null)?.count ?? 0; // Adjust type assertion as needed


    if (expenseCount > 0) {
        throw new Error(`Cannot delete category: It is assigned to ${expenseCount} expense(s).`);
    }

    // Proceed with deletion if no expenses are linked
    const { error } = await supabase
        .from("categories")
        .delete()
        .eq("id", id);

    if (error) {
        console.error("Error deleting category:", error);
        throw new Error(`Could not delete category. ${error.message || '(Check Supabase RLS/Permissions)'}`);
    }

    revalidatePath("/");
}

// --- AI Receipt Processing Action ---

/**
 * Processes a receipt file (image or PDF) using an AI flow to extract items.
 * Calls the Genkit flow `extractReceiptData`.
 * @param fileDataUri The receipt file encoded as a data URI.
 * @returns A promise that resolves to an array of extracted items, including suggested category IDs.
 */
export async function processReceiptFile(fileDataUri: string): Promise<ExtractedReceiptItem[]> {
    try {
        // Fetch current categories to ensure AI suggestions are validated against available ones
        const categories = await getCategories();
        const validCategoryIds = categories.map(c => c.id);
        // Ensure a valid default exists, even if 'other' is missing
        const defaultCategoryId = categories.find(c => c.id === 'other')?.id || categories[0]?.id;
        if (!defaultCategoryId && categories.length > 0) { // Check if categories array is not empty before throwing
             throw new Error("No default category ('other' or first category) available to assign.");
        } else if (categories.length === 0) {
             throw new Error("No categories found in the database. Cannot process receipt.");
        }


        // Call the AI flow which returns items with categoryId suggestions
        const result = await extractReceiptData({ fileDataUri });

        // Validate AI's suggested category IDs against the actual categories from the DB
        const validatedResults = result.map(item => ({
            ...item,
            categoryId: validCategoryIds.includes(item.categoryId) ? item.categoryId : defaultCategoryId
        }));

        return validatedResults;
    } catch (error) {
        console.error("Error processing receipt with AI:", error);
        if (error instanceof z.ZodError) {
             console.error("Zod validation error during AI processing:", error.errors);
             throw new Error("Invalid data structure received from AI processing.");
        } else if (error instanceof Error) {
             // Make error message more user-friendly
             if (error.message.includes("No categories found")) {
                 throw new Error("Cannot process receipt: No categories are set up in the application.");
             }
             throw new Error(`Failed to process receipt: ${error.message}`);
        } else {
            throw new Error("An unknown error occurred while processing the receipt.");
        }
    }
}

// --- AI Category Suggestion Action ---
/**
 * Suggests a category ID based on the item description using a Genkit AI flow.
 * @param description The description of the expense item.
 * @returns A suggested category ID string or null if no suggestion is made or an error occurs.
 */
export async function suggestCategory(description: string): Promise<string | null> {
  if (!description || description.trim().length === 0) {
    return null;
  }
  try {
    const categories = await getCategories();
    if (categories.length === 0) {
        console.warn("Cannot suggest category: No categories found in the database.");
        return null; // Or return 'other' if it exists conceptually
    }
    const categoryList = categories.map(c => ({ id: c.id, name: c.name }));
    const defaultCategoryId = categories.find(c => c.id === 'other')?.id || null; // Prefer null if 'other' doesn't exist

    const result = await suggestCategoryFlow({ description, categories: categoryList });

    // Validate the suggestion against existing categories
    if (result.categoryId && categories.some(c => c.id === result.categoryId)) {
        return result.categoryId;
    } else {
        console.warn(`AI suggested category "${result.categoryId}" which is not in the database or is null. Falling back to default.`);
        return defaultCategoryId; // Fallback to 'other' (or null if 'other' doesn't exist)
    }
  } catch (error) {
    console.error("Error suggesting category with AI:", error);
    return null; // Return null on error
  }
}
