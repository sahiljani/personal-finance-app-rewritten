"use server";

import { type Expense, type Category, type ExtractedReceiptItem } from "@/lib/types";
import { z } from "zod";
import { revalidatePath } from "next/cache";
import { createClient } from "@/lib/supabase/client"; // Import Supabase server client factory function
import { extractReceiptData } from "@/ai/flows/extract-receipt-data";
import { suggestCategoryFlow } from "@/ai/flows/suggest-category-flow";

// --- Data Schemas (using Supabase conventions) ---

// Category Schema matches the DB table
const CategorySchema = z.object({
  id: z.string().uuid().optional(), // UUID generated by DB or client
  name: z.string().min(1, "Category name cannot be empty"),
  icon: z.string().optional().nullable(), // Allow null in DB
  created_at: z.string().datetime().optional(), // Timestamps handled by DB
});

// Expense Schema matches the DB table
const ExpenseSchema = z.object({
  id: z.string().uuid().optional(), // UUID generated by DB
  amount: z.coerce.number({invalid_type_error: "Amount must be a number."}).positive("Amount must be positive"), // Use coerce for string conversion
  description: z.string().min(1, "Description cannot be empty").max(100, "Description too long (max 100 chars)."), // Added max length
  category_id: z.string().min(1, "Category is required"), // Use category_id (matches DB foreign key)
  date: z.string().datetime("Invalid date format"), // ISO 8601 string
  receipt_url: z.string().optional().nullable(), // Allow null in DB
  created_at: z.string().datetime().optional(), // Timestamps handled by DB
});

// Type mapping to frontend types (adjust if needed)
function mapExpenseFromDb(dbExpense: any): Expense {
  // Basic validation to ensure dbExpense is an object and has necessary fields
  if (typeof dbExpense !== 'object' || dbExpense === null || !dbExpense.id || !dbExpense.date) {
     console.error("Invalid data received in mapExpenseFromDb:", dbExpense);
     // In a production app, you might want to handle this more gracefully,
     // maybe filter out invalid items or return a default structure.
     // For now, throwing an error highlights the data integrity issue.
     throw new Error("Invalid database expense data received.");
  }
  return {
    id: dbExpense.id,
    amount: Number(dbExpense.amount) || 0, // Ensure amount is number
    description: dbExpense.description ?? '', // Ensure description is string
    categoryId: dbExpense.category_id ?? '', // Ensure categoryId is string
    date: dbExpense.date, // Assume date is correct format from DB
    receiptUrl: dbExpense.receipt_url,
  };
}

function mapCategoryFromDb(dbCategory: any): Category {
   // Basic validation
   if (typeof dbCategory !== 'object' || dbCategory === null || !dbCategory.id || !dbCategory.name) {
      console.error("Invalid data received in mapCategoryFromDb:", dbCategory);
      throw new Error("Invalid database category data received.");
   }
  return {
    id: dbCategory.id,
    name: dbCategory.name,
    icon: dbCategory.icon,
  };
}


// --- Expense Actions ---

export async function getExpenses(
  filters?: { dateFrom?: string; dateTo?: string; categoryId?: string }
): Promise<Expense[]> {
  const supabase = createClient(); // Create client inside the action
  let query = supabase.from("expenses").select("*");

  // Apply filters
  if (filters?.dateFrom) {
    query = query.gte('date', filters.dateFrom);
  }
  if (filters?.dateTo) {
    // Adjust end date to be inclusive (end of the day) or exclusive (start of next day)
    const endDate = new Date(filters.dateTo);
    endDate.setDate(endDate.getDate() + 1);
    query = query.lt('date', endDate.toISOString().split('T')[0]); // Use 'YYYY-MM-DD' format
  }
  if (filters?.categoryId) {
    query = query.eq('category_id', filters.categoryId); // Use DB column name
  }

  // Order by date descending
  query = query.order('date', { ascending: false });

  const { data, error } = await query;

  if (error) {
      // Log the detailed error object from Supabase
      console.error("Error fetching expenses (Raw Object):", error);
      const errorMessage = error?.message ?? 'N/A';
      const errorCode = error?.code ?? 'N/A';
      const errorDetails = error?.details ?? 'N/A';
      const errorHint = error?.hint ?? 'N/A';
      console.error(`Error fetching expenses (Message): ${errorMessage}, (Code): ${errorCode}, (Details): ${errorDetails}, (Hint): ${errorHint}`);

      // Provide more specific error context if possible
      let userMessage = "Could not fetch expenses.";
       if (errorCode === '42P01') { // PostgreSQL error code for 'undefined_table'
           userMessage = "Database error: The 'expenses' table could not be found. Please check the database schema setup instructions in README.md and ensure migrations have been applied.";
       } else if (errorMessage.includes('permission denied')) { // Check for RLS issues
           userMessage = "Permission denied fetching expenses. Please check Row Level Security (RLS) policies on the 'expenses' table in Supabase to allow read access.";
       } else if (errorMessage.includes('NetworkError')) {
           userMessage = "Network error: Could not connect to the database.";
       } else if (errorMessage.includes('Invalid API key') || errorMessage.includes('Unauthorized')) {
           userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
       } else {
           // Fallback using Supabase error details if available
            userMessage += ` ${errorMessage || '(Check Supabase connection/permissions)'}${errorDetails ? ` (${errorDetails})` : ''}`;
       }
      console.error("Throwing user-facing error:", userMessage); // Log the final error message being thrown
      throw new Error(userMessage);
  }

  try {
      // Add explicit validation/mapping step
      return data?.map(mapExpenseFromDb) ?? [];
  } catch (mappingError) {
      console.error("Error mapping database expenses to frontend type:", mappingError);
      throw new Error("Failed to process expense data from database.");
  }
}

export async function addExpense(expenseData: Omit<Expense, "id" | "receiptUrl"> & { receiptUrl?: string | null }): Promise<Expense> {
   const supabase = createClient(); // Create client inside the action
   // Validate incoming data against the frontend structure first
    const partialFrontendSchema = ExpenseSchema.omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
       categoryId: z.string().min(1, "Category is required"),
       receiptUrl: z.string().optional().nullable(),
       date: z.string().datetime("Invalid date format"), // Ensure date is validated here
   });

   // Use safeParse to handle validation errors gracefully
    const validationResult = partialFrontendSchema.safeParse(expenseData);
    if (!validationResult.success) {
         console.error("Invalid expense data:", validationResult.error.flatten());
         // Provide a clearer error message to the frontend
         const fieldErrors = JSON.stringify(validationResult.error.flatten().fieldErrors);
         throw new Error(`Invalid expense data provided. Errors: ${fieldErrors}`);
    }
    const validatedFrontendData = validationResult.data;

   // Prepare data for Supabase insertion (map frontend fields to DB fields)
    const dataToInsert = {
        amount: validatedFrontendData.amount,
        description: validatedFrontendData.description,
        category_id: validatedFrontendData.categoryId, // Map to category_id
        date: validatedFrontendData.date,
        receipt_url: validatedFrontendData.receiptUrl,
    };

    // Insert into Supabase
    const { data, error } = await supabase
        .from("expenses")
        .insert(dataToInsert)
        .select() // Return the inserted row
        .single(); // Expect only one row back

    if (error) {
        console.error("Error adding expense:", error);
        let userMessage = "Could not add expense.";
        if (error.code === '23503') { // Foreign key violation
             userMessage = "Could not add expense: Invalid category selected.";
        } else if (error.code === '42P01') {
            userMessage = "Database error: The 'expenses' table could not be found. Check schema/migrations.";
        } else if (error.message && error.message.includes('permission denied')) {
             userMessage = "Permission denied adding expense. Check RLS policies on 'expenses'.";
        } else if (error.message && (error.message.includes('Invalid API key') || error.message.includes('Unauthorized'))) {
           userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
        } else {
            userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }

    revalidatePath("/");
    revalidatePath("/reports");

     try {
        // Map DB result back to frontend type
        return mapExpenseFromDb(data);
    } catch (mappingError) {
        console.error("Error mapping added expense from DB:", mappingError);
        throw new Error("Expense added, but failed to process the returned data.");
    }
}

export async function addExpensesBatch(expenseDataArray: Omit<Expense, "id" | "receiptUrl">[]): Promise<Expense[]> {
    const supabase = createClient(); // Create client inside the action
    const expensesToInsert = expenseDataArray.map((expenseData, index) => {
         // Validate each item individually (optional, but good practice)
         const partialFrontendSchema = ExpenseSchema.omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
            categoryId: z.string().min(1, "Category is required"),
            receiptUrl: z.string().optional().nullable(),
            date: z.string().datetime("Invalid date format"), // Ensure date is validated here
         });

         const validationResult = partialFrontendSchema.safeParse(expenseData);
         if (!validationResult.success) {
             console.error(`Invalid data for batch item index ${index}:`, validationResult.error.flatten());
             const fieldErrors = JSON.stringify(validationResult.error.flatten().fieldErrors);
             // Throw error for the first invalid item found
             throw new Error(`Invalid data for expense item at index ${index}. Errors: ${fieldErrors}`);
         }
          const validatedFrontendData = validationResult.data;

         return {
             amount: validatedFrontendData.amount,
             description: validatedFrontendData.description,
             category_id: validatedFrontendData.categoryId,
             date: validatedFrontendData.date,
             receipt_url: validatedFrontendData.receiptUrl,
         };
    });

    const { data, error } = await supabase
        .from("expenses")
        .insert(expensesToInsert)
        .select();

    if (error) {
        console.error("Error adding expenses batch:", error);
         let userMessage = "Could not add expenses batch.";
         if (error.code === '42P01') {
             userMessage = "Database error: The 'expenses' table could not be found. Check schema/migrations.";
         } else if (error.message && error.message.includes('permission denied')) {
              userMessage = "Permission denied adding expenses batch. Check RLS policies on 'expenses'.";
         } else if (error.message && (error.message.includes('Invalid API key') || error.message.includes('Unauthorized'))) {
            userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
         } else {
             userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
         }
        throw new Error(userMessage);
    }

    revalidatePath("/");
    revalidatePath("/reports");

     try {
        return data?.map(mapExpenseFromDb) ?? [];
    } catch (mappingError) {
        console.error("Error mapping batch added expenses from DB:", mappingError);
        throw new Error("Expenses added, but failed to process the returned data.");
    }
}


export async function updateExpense(id: string, updates: Partial<Omit<Expense, "id" | "receiptUrl">> & { receiptUrl?: string | null }): Promise<Expense> {
    const supabase = createClient(); // Create client inside the action
    // Validate the partial update data
    const partialFrontendSchema = ExpenseSchema.partial().omit({ id: true, created_at: true, category_id: true, receipt_url: true }).extend({
        categoryId: z.string().optional(),
        receiptUrl: z.string().optional().nullable(),
        date: z.string().datetime("Invalid date format").optional(), // Allow optional date update
        amount: z.coerce.number().positive("Amount must be positive").optional(), // Validate amount if provided
        description: z.string().min(1, "Description cannot be empty").max(100, "Description too long").optional(), // Validate description if provided
    });

    // Use safeParse for validation
    const validationResult = partialFrontendSchema.safeParse(updates);
    if (!validationResult.success) {
        console.error("Invalid update data:", validationResult.error.flatten());
        const fieldErrors = JSON.stringify(validationResult.error.flatten().fieldErrors);
        throw new Error(`Invalid update data provided. Errors: ${fieldErrors}`);
    }
    const validatedUpdates = validationResult.data;


    // Map frontend fields to DB fields for the update payload
    const dataToUpdate: { [key: string]: any } = {};
    if (validatedUpdates.amount !== undefined) dataToUpdate.amount = validatedUpdates.amount;
    if (validatedUpdates.description !== undefined) dataToUpdate.description = validatedUpdates.description;
    if (validatedUpdates.categoryId !== undefined) dataToUpdate.category_id = validatedUpdates.categoryId;
    if (validatedUpdates.date !== undefined) dataToUpdate.date = validatedUpdates.date;
    if (validatedUpdates.receiptUrl !== undefined) dataToUpdate.receipt_url = validatedUpdates.receiptUrl;

     // Check if there's anything to update
    if (Object.keys(dataToUpdate).length === 0) {
       // Fetch the current expense if no updates are provided
        const { data: currentData, error: currentError } = await supabase
            .from('expenses')
            .select('*')
            .eq('id', id)
            .single();
        if (currentError || !currentData) {
             console.error("Error fetching expense for empty update:", currentError);
             throw new Error(`Expense with ID ${id} not found or could not be fetched.`);
        }
         return mapExpenseFromDb(currentData);
     }


    const { data, error } = await supabase
        .from("expenses")
        .update(dataToUpdate)
        .eq("id", id)
        .select()
        .single();

    if (error) {
        console.error("Error updating expense:", error);
        let userMessage = "Could not update expense.";
         if (error.code === 'PGRST116' || error.message.includes('0 rows') ) { // Resource Not Found (PostgREST code) or message
            userMessage = `Expense with ID ${id} not found for update.`;
        } else if (error.code === '23503') { // Foreign key violation
            userMessage = "Could not update expense: Invalid category selected.";
        } else if (error.code === '42P01') {
             userMessage = "Database error: The 'expenses' table could not be found. Check schema/migrations.";
        } else if (error.message && error.message.includes('permission denied')) {
             userMessage = "Permission denied updating expense. Check RLS policies on 'expenses'.";
        } else if (error.message && (error.message.includes('Invalid API key') || error.message.includes('Unauthorized'))) {
             userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
        } else {
            userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }
     if (!data) {
         // This case might be redundant if PGRST116 or "0 rows" is caught above, but good for safety
         throw new Error(`Expense with ID ${id} not found after update attempt.`);
     }

    revalidatePath("/");
    revalidatePath("/reports");
    try {
        return mapExpenseFromDb(data);
     } catch (mappingError) {
         console.error("Error mapping updated expense from DB:", mappingError);
         throw new Error("Expense updated, but failed to process the returned data.");
     }
}

export async function deleteExpense(id: string): Promise<void> {
    const supabase = createClient(); // Create client inside the action
    const { error } = await supabase
        .from("expenses")
        .delete()
        .eq("id", id);

    if (error) {
        console.error("Error deleting expense:", error);
        let userMessage = "Could not delete expense.";
         if (error.code === '42P01') {
             userMessage = "Database error: The 'expenses' table could not be found. Check schema/migrations.";
         } else if (error.message && error.message.includes('permission denied')) {
              userMessage = "Permission denied deleting expense. Check RLS policies on 'expenses'.";
         } else if (error.message && (error.message.includes('Invalid API key') || error.message.includes('Unauthorized'))) {
             userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
         } else {
            userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
         }
        throw new Error(userMessage);
    }
    // We can't easily check if a row was actually deleted without another query,
    // but Supabase delete doesn't error if the row doesn't exist with `eq`.

    revalidatePath("/");
    revalidatePath("/reports");
}


// --- Category Actions ---

export async function getCategories(): Promise<Category[]> {
    const supabase = createClient(); // Create client inside the action
    const { data, error } = await supabase
        .from("categories")
        .select("*")
        .order('name', { ascending: true }); // Optional: order by name

    if (error) {
        // Log the detailed error object from Supabase
        console.error("Error fetching categories (Raw Object):", error);
        const errorMessage = error?.message ?? 'N/A';
        const errorCode = error?.code ?? 'N/A';
        const errorDetails = error?.details ?? 'N/A';
        const errorHint = error?.hint ?? 'N/A';
        console.error(`Error fetching categories (Message): ${errorMessage}, (Code): ${errorCode}, (Details): ${errorDetails}, (Hint): ${errorHint}`);

        // For other errors, construct a user-friendly message and throw
        let userMessage = "Could not fetch categories.";
         if (errorCode === '42P01') { // PostgreSQL error code for 'undefined_table'
           userMessage = "Database error: The 'categories' table could not be found. Please check the database schema setup instructions in README.md and ensure migrations have been applied.";
         } else if (errorMessage.includes('permission denied')) { // Check for RLS issues
           userMessage = "Permission denied fetching categories. Please check Row Level Security (RLS) policies on the 'categories' table in Supabase to allow read access.";
        } else if (errorMessage.includes('NetworkError')) {
           userMessage = "Network error: Could not connect to the database.";
        } else if (errorMessage.includes('Invalid API key') || errorMessage.includes('Unauthorized')) {
            userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
        } else {
            // Fallback using Supabase error details if available
            userMessage += ` ${errorMessage || '(Check Supabase RLS/Permissions)'}${errorDetails ? ` (${errorDetails})` : ''}`;
        }
        console.error("Throwing user-facing error:", userMessage); // Log the final error message being thrown
        throw new Error(userMessage);
    }


     try {
        // Add explicit validation/mapping step
        return data?.map(mapCategoryFromDb) ?? [];
    } catch (mappingError) {
        console.error("Error mapping database categories to frontend type:", mappingError);
        throw new Error("Failed to process category data from database.");
    }
}

// Note: Adding categories might require specific DB setup (e.g., RLS policies)
// The ID is usually handled by Supabase (UUID)
export async function addCategory(categoryData: Omit<Category, "id">): Promise<Category> {
    const supabase = createClient(); // Create client inside the action
     // Validate incoming data
     const validationResult = CategorySchema.omit({ id: true, created_at: true }).safeParse(categoryData);
     if (!validationResult.success) {
         console.error("Invalid category data:", validationResult.error.flatten());
         const fieldErrors = JSON.stringify(validationResult.error.flatten().fieldErrors);
         throw new Error(`Invalid category data provided. Errors: ${fieldErrors}`);
     }
     const validatedData = validationResult.data;

     // Optional: Check for duplicate names server-side before inserting
     const { data: existing, error: existingError } = await supabase
         .from('categories')
         .select('id')
         .ilike('name', validatedData.name) // Case-insensitive check
         .maybeSingle();

      if (existingError && existingError.code !== '42P01') { // Ignore table not found error during check
           console.error("Error checking for existing category:", existingError);
          // Decide if this is fatal or just a warning
           throw new Error(`Could not verify existing categories. ${existingError.message}`);
      }
      if (existing) {
          throw new Error(`Category with name "${validatedData.name}" already exists.`);
      }

    const { data, error } = await supabase
        .from("categories")
        .insert({
            name: validatedData.name,
            icon: validatedData.icon,
        })
        .select()
        .single();

    if (error) {
        console.error("Error adding category:", error);
        let userMessage = "Could not add category.";
        if (error.code === '42P01') {
             userMessage = "Database error: The 'categories' table could not be found. Check schema/migrations.";
        } else if (error.message && error.message.includes('permission denied')) {
             userMessage = "Permission denied adding category. Check RLS policies on 'categories'.";
        } else if (error.message && (error.message.includes('Invalid API key') || error.message.includes('Unauthorized'))) {
            userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
        } else {
             userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }

    revalidatePath("/");
    revalidatePath("/settings"); // Revalidate settings if categories managed there
     try {
         return mapCategoryFromDb(data);
     } catch (mappingError) {
         console.error("Error mapping added category from DB:", mappingError);
         throw new Error("Category added, but failed to process the returned data.");
     }
}

export async function updateCategory(id: string, updates: Partial<Omit<Category, "id">>): Promise<Category> {
    const supabase = createClient(); // Create client inside the action
    const partialSchema = CategorySchema.partial().omit({ id: true, created_at: true });
    // Validate incoming update data
    const validationResult = partialSchema.safeParse(updates);
    if (!validationResult.success) {
        console.error("Invalid category update data:", validationResult.error.flatten());
        const fieldErrors = JSON.stringify(validationResult.error.flatten().fieldErrors);
        throw new Error(`Invalid category update data provided. Errors: ${fieldErrors}`);
    }
    const validatedUpdates = validationResult.data;

     // Optional: Check for duplicate names if name is changing
     if (validatedUpdates.name) {
         const { data: existing, error: existingError } = await supabase
             .from('categories')
             .select('id')
             .ilike('name', validatedUpdates.name)
             .neq('id', id) // Exclude the current category being updated
             .maybeSingle();

         if (existingError && existingError.code !== '42P01') { // Ignore table not found
             console.error("Error checking for existing category name:", existingError);
             throw new Error(`Could not verify existing category name. ${existingError.message}`);
         }
         if (existing) {
             throw new Error(`Another category with the name "${validatedUpdates.name}" already exists.`);
         }
     }

     // Map validated updates to DB schema if necessary (already matching here)
     const dataToUpdate = { ...validatedUpdates };

     // Check if there's anything to update
     if (Object.keys(dataToUpdate).length === 0) {
         // Fetch and return current category if no updates
         const { data: currentData, error: currentError } = await supabase
             .from('categories')
             .select('*')
             .eq('id', id)
             .single();
         if (currentError || !currentData) {
             console.error(`Error fetching category ${id} for empty update:`, currentError);
             throw new Error(`Category with ID ${id} not found or could not be fetched.`);
         }
         return mapCategoryFromDb(currentData);
     }


    const { data, error } = await supabase
        .from("categories")
        .update(dataToUpdate)
        .eq("id", id)
        .select()
        .single();

    if (error) {
        console.error("Error updating category:", error);
        let userMessage = "Could not update category.";
         if (error.code === 'PGRST116' || error.message.includes('0 rows')) {
            userMessage = `Category with ID ${id} not found for update.`;
        } else if (error.code === '42P01') {
             userMessage = "Database error: The 'categories' table could not be found. Check schema/migrations.";
        } else if (error.message && error.message.includes('permission denied')) {
             userMessage = "Permission denied updating category. Check RLS policies on 'categories'.";
        } else if (error.message && (error.message.includes('Invalid API key') || error.message.includes('Unauthorized'))) {
            userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
        } else {
             userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }
     if (!data) {
         throw new Error(`Category with ID ${id} not found after update attempt.`);
     }

    revalidatePath("/");
    revalidatePath("/settings"); // Revalidate settings if categories managed there
     try {
         return mapCategoryFromDb(data);
     } catch (mappingError) {
         console.error("Error mapping updated category from DB:", mappingError);
         throw new Error("Category updated, but failed to process the returned data.");
     }
}

export async function deleteCategory(id: string): Promise<void> {
    const supabase = createClient(); // Create client inside the action

    // Check if any expenses use this category
    // Important: Ensure RLS allows checking expenses table if applicable
     const { count, error: expensesError } = await supabase
         .from('expenses')
         .select('id', { count: 'exact', head: true }) // Use head: true for count only
         .eq('category_id', id); // Filter by the category being deleted

     if (expensesError) {
         console.error("Error checking for expenses linked to category:", expensesError);
         // Check specifically for missing 'expenses' table
         if (expensesError.code === '42P01') {
             // If expenses table doesn't exist, we can proceed to delete category
             console.warn("Could not check for linked expenses because the 'expenses' table was not found. Proceeding with category deletion.");
         } else if (expensesError.message && expensesError.message.includes('permission denied')) {
             throw new Error("Permission denied checking linked expenses. Check RLS policies on 'expenses'.");
         } else {
            throw new Error(`Could not verify if category is in use. ${expensesError.message}`);
         }
     }

     const expenseCount = count ?? 0;

    if (expenseCount > 0) {
        throw new Error(`Cannot delete category: It is assigned to ${expenseCount} expense(s). Please reassign them first.`);
    }

    // Proceed with deletion if no expenses are linked or expenses table doesn't exist
    const { error } = await supabase
        .from("categories")
        .delete()
        .eq("id", id);

    if (error) {
        console.error("Error deleting category:", error);
        let userMessage = "Could not delete category.";
        if (error.code === '42P01') {
            userMessage = "Database error: The 'categories' table could not be found. Check schema/migrations.";
        } else if (error.message && error.message.includes('permission denied')) {
             userMessage = "Permission denied deleting category. Check RLS policies on 'categories'.";
        } else if (error.message && (error.message.includes('Invalid API key') || error.message.includes('Unauthorized'))) {
            userMessage = "Authentication error: Invalid Supabase API key or permissions. Check your .env file and RLS policies.";
        } else {
            userMessage += ` ${error.message || '(Check Supabase RLS/Permissions)'}`;
        }
        throw new Error(userMessage);
    }

    revalidatePath("/");
    revalidatePath("/settings"); // Revalidate settings if categories managed there
}

// --- AI Receipt Processing Action ---

/**
 * Processes a receipt file (image or PDF) using an AI flow to extract items.
 * Calls the Genkit flow `extractReceiptData`.
 * @param fileDataUri The receipt file encoded as a data URI.
 * @returns A promise that resolves to an array of extracted items, including suggested category IDs.
 */
export async function processReceiptFile(fileDataUri: string): Promise<ExtractedReceiptItem[]> {
    try {
        // Fetch current categories to ensure AI suggestions are validated against available ones
        const categories = await getCategories();

        // Check if categories array is empty after fetching
        if (categories.length === 0) {
            console.error("No categories found in the database. Cannot process receipt without categories.");
            // Throw a specific error that can be caught in the UI
            throw new Error("No expense categories found. Please add some categories in the settings before processing receipts.");
        }

        const validCategoryIds = categories.map(c => c.id);
        // Ensure a valid default exists, even if 'other' is missing
        const defaultCategoryId = categories.find(c => c.id === 'other')?.id || categories[0].id; // Use first category if 'other' is missing

        // Call the AI flow which returns items with categoryId suggestions
        const result = await extractReceiptData({ fileDataUri });

        // Validate AI's suggested category IDs against the actual categories from the DB
        const validatedResults = result.map(item => ({
            ...item,
            categoryId: validCategoryIds.includes(item.categoryId) ? item.categoryId : defaultCategoryId
        }));

        return validatedResults;
    } catch (error) {
        console.error("Error processing receipt with AI:", error);
        if (error instanceof z.ZodError) {
             console.error("Zod validation error during AI processing:", error.errors);
             throw new Error("Invalid data structure received from AI processing.");
        } else if (error instanceof Error) {
             // Pass through specific errors from getCategories or AI flow if relevant
             if (error.message.includes("No expense categories found")) {
                 throw error; // Re-throw the specific error about missing categories
             }
              if (error.message.includes("Database error:") || error.message.includes("Network error:") || error.message.includes("Authentication error:")){
                 throw new Error(`Database or connection error prevented receipt processing: ${error.message}`);
              }
             // Handle other potential errors (e.g., AI service unavailable)
             throw new Error(`Failed to process receipt: ${error.message}`);
        } else {
            throw new Error("An unknown error occurred while processing the receipt.");
        }
    }
}

// --- AI Category Suggestion Action ---
/**
 * Suggests a category ID based on the item description using a Genkit AI flow.
 * @param description The description of the expense item.
 * @returns A suggested category ID string or null if no suggestion is made or an error occurs.
 */
export async function suggestCategory(description: string): Promise<string | null> {
  if (!description || description.trim().length === 0) {
    return null;
  }
  try {
    const categories = await getCategories();
    if (categories.length === 0) {
        console.warn("Cannot suggest category: No categories found in the database.");
        return null; // Return null if no categories exist
    }
    const categoryList = categories.map(c => ({ id: c.id, name: c.name }));
    const defaultCategoryId = categories.find(c => c.id === 'other')?.id || null; // Prefer null if 'other' doesn't exist

    const result = await suggestCategoryFlow({ description, categories: categoryList });

    // Validate the suggestion against existing categories
    if (result.categoryId && categories.some(c => c.id === result.categoryId)) {
        return result.categoryId;
    } else {
        console.warn(`AI suggested category "${result.categoryId}" which is not in the database or is null. Falling back to default.`);
        return defaultCategoryId; // Fallback to 'other' (or null if 'other' doesn't exist)
    }
  } catch (error) {
    console.error("Error suggesting category with AI:", error);
     // Avoid propagating raw DB errors to the frontend suggestion mechanism
     if (error instanceof Error && (error.message.includes("Database error:") || error.message.includes("Network error:") || error.message.includes("Authentication error:"))){
         console.error("Database/Network/Auth error prevented category suggestion.");
         return null;
     }
      // Handle specific "No categories" error from getCategories gracefully
     if (error instanceof Error && error.message.includes("No categories found")) {
         console.warn("Cannot suggest category: " + error.message);
         return null;
     }
    return null; // Return null on other errors
  }
}

// --- Database Initialization & Seeding ---

/**
 * Checks if the required database tables exist and attempts to seed initial categories if the table is empty.
 * This is NOT a full migration solution. Use Supabase CLI for proper migrations (`supabase db push`).
 * It returns true if checks pass or seeding is successful, false otherwise.
 */
export async function createRequiredTables(): Promise<boolean> {
    const supabase = createClient();

    try {
        // Check Categories Table Existence
        const { error: catCheckError } = await supabase
            .from('categories')
            .select('id', { count: 'exact', head: true }) // Efficiently check if table exists and is queryable
             .limit(1); // Only need to know if it exists

        if (catCheckError) {
            if (catCheckError.code === '42P01') { // Table doesn't exist
                console.error("Database Error: 'categories' table not found. Please run migrations (see README.md).");
                // Consider trying to create it here ONLY if absolutely necessary and with proper permissions
                // return await attemptCreateTableAndSeed(supabase); // Example: Separate function for creation logic
                return false; // Indicate setup failure
            } else {
                console.error("Error checking 'categories' table:", catCheckError);
                 throw new Error(`Could not verify 'categories' table. ${catCheckError.message}`);
            }
        } else {
            console.log("'categories' table exists.");
            // If table exists, attempt seeding if it's empty
            await seedInitialCategories(supabase);
        }

        // Check Expenses Table Existence
        const { error: expCheckError } = await supabase
            .from('expenses')
            .select('id', { count: 'exact', head: true })
            .limit(1);

        if (expCheckError) {
             if (expCheckError.code === '42P01') { // Table doesn't exist
                console.error("Database Error: 'expenses' table not found. Please run migrations (see README.md).");
                 // Consider trying to create it here ONLY if absolutely necessary and with proper permissions
                 // return await attemptCreateTableAndSeed(supabase); // Example
                 return false; // Indicate setup failure
             } else {
                 console.error("Error checking 'expenses' table:", expCheckError);
                 throw new Error(`Could not verify 'expenses' table. ${expCheckError.message}`);
             }
        } else {
             console.log("'expenses' table exists.");
        }

        console.log("Database table check completed successfully.");
        return true; // Tables exist

    } catch (error) {
        console.error("Error during database table check/setup:", error);
        // Provide a generic failure message, details logged above
        return false;
    }
}

// Helper to seed initial categories ONLY if the table is empty
async function seedInitialCategories(supabase: any) {
    const initialCategories = [
        { id: 'outside-food', name: 'Outside Food', icon: 'Utensils' },
        { id: 'grocery', name: 'Grocery', icon: 'ShoppingCart' },
        { id: 'transportation', name: 'Transportation', icon: 'Car' },
        { id: 'housing', name: 'Housing', icon: 'Home' },
        { id: 'utilities', name: 'Utilities', icon: 'Lightbulb' },
        { id: 'entertainment', name: 'Entertainment', icon: 'Ticket' },
        { id: 'shopping', name: 'Shopping', icon: 'ShoppingBag' },
        { id: 'clothing', name: 'Clothing', icon: 'Shirt' },
        { id: 'electronics', name: 'Electronics', icon: 'Smartphone' },
        { id: 'books', name: 'Books', icon: 'BookOpen' },
        { id: 'tools', name: 'Tools', icon: 'Wrench' },
        { id: 'health', name: 'Health', icon: 'HeartPulse' },
        { id: 'other', name: 'Other', icon: 'HelpCircle' }
    ];

    try {
        // Check if the table is empty before attempting to seed
         const { count, error: countError } = await supabase
             .from('categories')
             .select('id', { count: 'exact', head: true });

         if (countError) {
             console.error("Error checking category count before seeding:", countError);
             // Don't throw here, allow the app to continue if possible, but log the issue.
             // Seeding will likely fail if the table is unreadable.
             return;
         }

         if (count === 0) {
             console.log("Seeding initial categories as the table is empty...");
             // Use upsert with ignoreDuplicates: false to insert only if IDs don't exist (safer)
             // Or simple insert if confident IDs are unique or handled by DB defaults
             const { error: insertError } = await supabase
                 .from('categories')
                 .insert(initialCategories);
                 // .upsert(initialCategories, { onConflict: 'id', ignoreDuplicates: false }); // Use upsert if IDs might clash

             if (insertError) {
                  console.error("Error seeding categories:", insertError);
                  if (insertError.message.includes('permission denied')) {
                       console.error("Hint: Check RLS insert policy on 'categories' table.");
                  } else if (insertError.code === '23505') { // Unique violation (e.g., if ID is not default UUID)
                       console.warn("Warning seeding categories: Some categories might already exist.");
                  }
             } else {
                 console.log("Initial categories seeded successfully.");
                 revalidatePath("/"); // Revalidate relevant paths after seeding
                 revalidatePath("/settings");
             }
         } else {
             console.log("Categories table already contains data, skipping seed.");
         }
    } catch (error) {
        // Catch potential errors during the check/seed process
        console.error("Unexpected error during category seeding process:", error);
        // Log specific known errors if possible
        if (error instanceof Error && error.message.includes('permission denied')) {
            console.error("Permission denied checking/seeding categories. Check RLS policies.");
        }
        // Do not throw here to avoid blocking app load unnecessarily, log instead.
    }
}

// IMPORTANT: Creating tables via RPC/SQL function is generally discouraged for migrations.
// Use Supabase CLI (`supabase db push`) or the dashboard SQL editor with the migration file.
// The `executeSql` function below is a placeholder and likely requires specific DB setup.
// async function executeSql(sql: string): Promise<{ data: any; error: any }> {
//     const supabase = createClient();
//     // This assumes you have a function `execute_sql` set up in Supabase
//     // See: https://supabase.com/docs/guides/database/functions#running-sql-statements
//     // WARNING: High security risk if `sql` is dynamic. Use ONLY with static strings.
//     return await supabase.rpc('execute_sql', { sql });
// }
